import{aj as P,ai as T,aL as O,i,aw as A,ak as X,k as l,bh as U,F as H,f as z,O as Z,aC as J,b0 as K,a as Q,E as p}from"./index-D0_VvR3J.js";const j=P({autoDraw:Boolean,autoDrawDuration:[Number,String],autoDrawEasing:{type:String,default:"ease"},color:String,gradient:{type:Array,default:()=>[]},gradientDirection:{type:String,validator:e=>["top","bottom","left","right"].includes(e),default:"top"},height:{type:[String,Number],default:75},labels:{type:Array,default:()=>[]},labelSize:{type:[Number,String],default:7},lineWidth:{type:[String,Number],default:4},id:String,itemValue:{type:String,default:"value"},modelValue:{type:Array,default:()=>[]},min:[String,Number],max:[String,Number],padding:{type:[String,Number],default:8},showLabels:Boolean,smooth:[Boolean,String,Number],width:{type:[Number,String],default:300}},"Line"),q=P({autoLineWidth:Boolean,...j()},"VBarline"),F=T()({name:"VBarline",props:q(),setup(e,r){let{slots:o}=r;const c=O(),n=i(()=>e.id||`barline-${c}`),g=i(()=>Number(e.autoDrawDuration)||500),h=i(()=>!!(e.showLabels||e.labels.length>0||o?.label)),u=i(()=>parseFloat(e.lineWidth)||4),f=i(()=>Math.max(e.modelValue.length*u.value,Number(e.width))),b=i(()=>({minX:0,maxX:f.value,minY:0,maxY:parseInt(e.height,10)})),$=i(()=>e.modelValue.map(t=>A(t,e.itemValue,t)));function D(t,a){const{minX:s,maxX:y,minY:m,maxY:d}=a,B=t.length;let N=e.max!=null?Number(e.max):Math.max(...t),V=e.min!=null?Number(e.min):Math.min(...t);V>0&&e.min==null&&(V=0),N<0&&e.max==null&&(N=0);const I=y/(B===1?2:B),L=(d-m)/(N-V||1),M=d-Math.abs(V*L);return t.map((k,_)=>{const Y=Math.abs(L*k);return{x:s+_*I,y:M-Y+ +(k<0)*Y,height:Y,value:k}})}const w=i(()=>{const t=[],a=D($.value,b.value),s=a.length;for(let y=0;t.length<s;y++){const m=a[y];let d=e.labels[y];d||(d=typeof m=="object"?m.value:m),t.push({x:m.x,value:String(d)})}return t}),x=i(()=>D($.value,b.value)),S=i(()=>x.value.length===1?(b.value.maxX-u.value)/2:(Math.abs(x.value[0].x-x.value[1].x)-u.value)/2),v=i(()=>typeof e.smooth=="boolean"?e.smooth?2:0:Number(e.smooth));X(()=>{const t=e.gradient.slice().length?e.gradient.slice().reverse():[""];return l("svg",{display:"block"},[l("defs",null,[l("linearGradient",{id:n.value,gradientUnits:"userSpaceOnUse",x1:e.gradientDirection==="left"?"100%":"0",y1:e.gradientDirection==="top"?"100%":"0",x2:e.gradientDirection==="right"?"100%":"0",y2:e.gradientDirection==="bottom"?"100%":"0"},[t.map((a,s)=>l("stop",{offset:s/Math.max(t.length-1,1),"stop-color":a||"currentColor"},null))])]),l("clipPath",{id:`${n.value}-clip`},[x.value.map(a=>l("rect",{x:a.x+S.value,y:a.y,width:u.value,height:a.height,rx:v.value,ry:v.value},[e.autoDraw&&!U()&&l(H,null,[l("animate",{attributeName:"y",from:a.y+a.height,to:a.y,dur:`${g.value}ms`,fill:"freeze"},null),l("animate",{attributeName:"height",from:"0",to:a.height,dur:`${g.value}ms`,fill:"freeze"},null)])]))]),h.value&&l("g",{key:"labels",style:{textAnchor:"middle",dominantBaseline:"mathematical",fill:"currentColor"}},[w.value.map((a,s)=>l("text",{x:a.x+S.value+u.value/2,y:parseInt(e.height,10)-2+(parseInt(e.labelSize,10)||7*.75),"font-size":Number(e.labelSize)||7},[o.label?.({index:s,value:a.value})??a.value]))]),l("g",{"clip-path":`url(#${n.value}-clip)`,fill:`url(#${n.value})`},[l("rect",{x:0,y:0,width:Math.max(e.modelValue.length*u.value,Number(e.width)),height:e.height},null)])])})}});function ee(e,r){let o=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1,c=arguments.length>3&&arguments[3]!==void 0?arguments[3]:75;if(e.length===0)return"";const n=e.shift(),g=e[e.length-1];return(o?`M${n.x} ${c-n.x+2} L${n.x} ${n.y}`:`M${n.x} ${n.y}`)+e.map((h,u)=>{const f=e[u+1],b=e[u-1]||n,$=f&&te(f,h,b);if(!f||$)return`L${h.x} ${h.y}`;const D=Math.min(R(b,h),R(f,h)),x=D/2<r?D/2:r,S=W(b,h,x),v=W(f,h,x);return`L${S.x} ${S.y}S${h.x} ${h.y} ${v.x} ${v.y}`}).join("")+(o?`L${g.x} ${c-n.x+2} Z`:"")}function C(e){return parseInt(e,10)}function te(e,r,o){return C(e.x+o.x)===C(2*r.x)&&C(e.y+o.y)===C(2*r.y)}function R(e,r){return Math.sqrt(Math.pow(r.x-e.x,2)+Math.pow(r.y-e.y,2))}function W(e,r,o){const c={x:e.x-r.x,y:e.y-r.y},n=Math.sqrt(c.x*c.x+c.y*c.y),g={x:c.x/n,y:c.y/n};return{x:r.x+g.x*o,y:r.y+g.y*o}}const G=P({fill:Boolean,...j()},"VTrendline"),E=T()({name:"VTrendline",props:G(),setup(e,r){let{slots:o}=r;const c=O(),n=i(()=>e.id||`trendline-${c}`),g=i(()=>Number(e.autoDrawDuration)||(e.fill?500:2e3)),h=z(0),u=z(null);function f(t,a){const{minX:s,maxX:y,minY:m,maxY:d}=a;t.length===1&&(t=[t[0],t[0]]);const B=t.length,N=e.max!=null?Number(e.max):Math.max(...t),V=e.min!=null?Number(e.min):Math.min(...t),I=(y-s)/(B-1),L=(d-m)/(N-V||1);return t.map((M,k)=>({x:s+k*I,y:d-(M-V)*L,value:M}))}const b=i(()=>!!(e.showLabels||e.labels.length>0||o?.label)),$=i(()=>parseFloat(e.lineWidth)||4),D=i(()=>Number(e.width)),w=i(()=>{const t=Number(e.padding);return{minX:t,maxX:D.value-t,minY:t,maxY:parseInt(e.height,10)-t}}),x=i(()=>e.modelValue.map(t=>A(t,e.itemValue,t))),S=i(()=>{const t=[],a=f(x.value,w.value),s=a.length;for(let y=0;t.length<s;y++){const m=a[y];let d=e.labels[y];d||(d=typeof m=="object"?m.value:m),t.push({x:m.x,value:String(d)})}return t});Z(()=>e.modelValue,async()=>{if(await J(),!e.autoDraw||!u.value||U())return;const t=u.value,a=t.getTotalLength();e.fill?(t.style.transformOrigin="bottom center",t.style.transition="none",t.style.transform="scaleY(0)",t.getBoundingClientRect(),t.style.transition=`transform ${g.value}ms ${e.autoDrawEasing}`,t.style.transform="scaleY(1)"):(t.style.strokeDasharray=`${a}`,t.style.strokeDashoffset=`${a}`,t.getBoundingClientRect(),t.style.transition=`stroke-dashoffset ${g.value}ms ${e.autoDrawEasing}`,t.style.strokeDashoffset="0"),h.value=a},{immediate:!0});function v(t){const a=typeof e.smooth=="boolean"?e.smooth?8:0:Number(e.smooth);return ee(f(x.value,w.value),a,t,parseInt(e.height,10))}X(()=>{const t=e.gradient.slice().length?e.gradient.slice().reverse():[""];return l("svg",{display:"block","stroke-width":parseFloat(e.lineWidth)??4},[l("defs",null,[l("linearGradient",{id:n.value,gradientUnits:"userSpaceOnUse",x1:e.gradientDirection==="left"?"100%":"0",y1:e.gradientDirection==="top"?"100%":"0",x2:e.gradientDirection==="right"?"100%":"0",y2:e.gradientDirection==="bottom"?"100%":"0"},[t.map((a,s)=>l("stop",{offset:s/Math.max(t.length-1,1),"stop-color":a||"currentColor"},null))])]),b.value&&l("g",{key:"labels",style:{textAnchor:"middle",dominantBaseline:"mathematical",fill:"currentColor"}},[S.value.map((a,s)=>l("text",{x:a.x+$.value/2+$.value/2,y:parseInt(e.height,10)-4+(parseInt(e.labelSize,10)||7*.75),"font-size":Number(e.labelSize)||7},[o.label?.({index:s,value:a.value})??a.value]))]),l("path",{ref:u,d:v(e.fill),fill:e.fill?`url(#${n.value})`:"none",stroke:e.fill?"none":`url(#${n.value})`},null),e.fill&&l("path",{d:v(!1),fill:"none",stroke:e.color??e.gradient?.[0]},null)])})}}),ae=P({type:{type:String,default:"trend"},...q(),...G()},"VSparkline"),le=T()({name:"VSparkline",props:ae(),setup(e,r){let{slots:o}=r;const{textColorClasses:c,textColorStyles:n}=K(()=>e.color),g=i(()=>!!(e.showLabels||e.labels.length>0||o?.label)),h=i(()=>{let u=parseInt(e.height,10);return g.value&&(u+=parseInt(e.labelSize,10)*1.5),u});X(()=>{const u=e.type==="trend"?E:F,f=e.type==="trend"?E.filterProps(e):F.filterProps(e);return Q(u,p({key:e.type,class:c.value,style:n.value,viewBox:`0 0 ${e.width} ${parseInt(h.value,10)}`},f),o)})}});export{le as V};
